## Question 01

在[内存访问检查](https://gaoyangu.github.io/wiki/ebpf/learning-ebpf-06/#6-7-Checking-Memory-Access)一节中，你已经看到校验器会拒绝超出全局消息数组末尾的内存访问操作。示例代码中有一个代码段，以类似的方式访问了局部变量 `data.message`：

```c
if (c < sizeof(data.message)) {
    char a = data.message[c];
    bpf_printk("%c", a);
} 
```

试着调整代码，把比较运算符 `<` 替换成 `<=`，人为制造这个差一越界错误，此时你会看到一条报错信息，内容为 “invalid variable-offset read from stack R2”。

## Answer

1. 修改代码

```diff
- if (c < sizeof(data.message)) {
+ if (c <= sizeof(data.message)) {
    char a = data.message[c];
    bpf_printk("%c", a);
} 
```

2. 编译运行

```sh
$ ./hello-verifier
...
invalid variable-offset read from stack R2 var_off=(0x0; 0xf) size=1
```

<details>
<summary>完整输出信息</summary>

```
libbpf: prog 'kprobe_exec': BPF program load failed: Invalid argument
libbpf: prog 'kprobe_exec': failed to load: -22
libbpf: failed to load object 'hello_verifier_bpf'
libbpf: failed to load BPF skeleton 'hello_verifier_bpf': -22
reg type unsupported for arg#0 function kprobe_exec#23
0: R1=ctx(off=0,imm=0) R10=fp0
; int kprobe_exec(void *ctx)
0: (bf) r6 = r1                       ; R1=ctx(off=0,imm=0) R6_w=ctx(off=0,imm=0)
; data.counter = c;
1: (18) r7 = 0xffffb05f40223000       ; R7_w=map_value(off=0,ks=4,vs=16,imm=0)
3: (61) r1 = *(u32 *)(r7 +0)          ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R7_w=map_value(off=0,ks=4,vs=16,imm=0)  
; c++;
4: (bf) r2 = r1                       ; R1_w=scalar(id=1,umax=4294967295,var_off=(0x0; 0xffffffff)) R2_w=scalar(id=1,umax=4294967295,va
r_off=(0x0; 0xffffffff))
5: (07) r2 += 1                       ; R2_w=scalar(umin=1,umax=4294967296,var_off=(0x0; 0x1ffffffff))
6: (63) *(u32 *)(r7 +0) = r2          ; R2_w=scalar(umin=1,umax=4294967296,var_off=(0x0; 0x1ffffffff)) R7_w=map_value(off=0,ks=4,vs=16,
imm=0)
7: (b7) r2 = 0                        ; R2_w=0
; struct data_t data = {};
8: (63) *(u32 *)(r10 -8) = r2         ; R2_w=0 R10=fp0 fp-8=????0000
9: (63) *(u32 *)(r10 -12) = r2        ; R2_w=0 R10=fp0 fp-16=0000????
10: (63) *(u32 *)(r10 -16) = r2       ; R2_w=0 R10=fp0 fp-16=00000000
11: (63) *(u32 *)(r10 -20) = r2       ; R2_w=0 R10=fp0 fp-24=0000????
12: (63) *(u32 *)(r10 -24) = r2       ; R2_w=0 R10=fp0 fp-24=00000000
13: (63) *(u32 *)(r10 -28) = r2       ; R2_w=0 R10=fp0 fp-32=0000????
14: (63) *(u32 *)(r10 -4) = r2        ; R2_w=0 R10=fp0 fp-8=00000000
; data.counter = c;
15: (63) *(u32 *)(r10 -32) = r1       ; R1_w=scalar(id=1,umax=4294967295,var_off=(0x0; 0xffffffff)) R10=fp0 fp-32=
; data.pid = bpf_get_current_pid_tgid();
16: (85) call bpf_get_current_pid_tgid#14     ; R0_w=scalar()
; data.pid = bpf_get_current_pid_tgid();
17: (63) *(u32 *)(r10 -40) = r0       ; R0_w=scalar() R10=fp0 fp-40=????mmmm
; uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
18: (85) call bpf_get_current_uid_gid#15      ; R0=scalar()
; data.uid = uid;
19: (63) *(u32 *)(r10 -36) = r0       ; R0=scalar() R10=fp0 fp-40=mmmmmmmm
; uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
20: (67) r0 <<= 32                    ; R0_w=scalar(smax=9223372032559808512,umax=18446744069414584320,var_off=(0x0; 0xffffffff00000000
),s32_min=0,s32_max=0,u32_max=0)
21: (77) r0 >>= 32                    ; R0_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff))
; uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
22: (7b) *(u64 *)(r10 -48) = r0       ; R0_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R10=fp0 fp-48_w=
23: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
;
24: (07) r2 += -48                    ; R2_w=fp-48
; p = bpf_map_lookup_elem(&my_config, &uid);
25: (18) r1 = 0xffff96bc1c712c00      ; R1_w=map_ptr(off=0,ks=4,vs=12,imm=0)
27: (85) call bpf_map_lookup_elem#1   ; R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0)
28: (18) r3 = 0xffffb05f40223004      ; R3_w=map_value(off=4,ks=4,vs=16,imm=0)
; if (p != 0) {
30: (15) if r0 == 0x0 goto pc+9       ; R0_w=map_value(off=0,ks=4,vs=12,imm=0)
; char a = p->message[0];
31: (71) r3 = *(u8 *)(r0 +0)          ; R0_w=map_value(off=0,ks=4,vs=12,imm=0) R3_w=scalar(umax=255,var_off=(0x0; 0xff))
32: (67) r3 <<= 56                    ; R3_w=scalar(smax=9151314442816847872,umax=18374686479671623680,var_off=(0x0; 0xff00000000000000
),s32_min=0,s32_max=0,u32_max=0)
33: (c7) r3 s>>= 56                   ; R3_w=scalar(smin=-128,smax=127)
; bpf_printk("%d", a);
34: (18) r1 = 0xffffb05f4023c000      ; R1_w=map_value(off=0,ks=4,vs=15,imm=0)
36: (b7) r2 = 3                       ; R2_w=3
37: (bf) r8 = r0                      ; R0_w=map_value(off=0,ks=4,vs=12,imm=0) R8_w=map_value(off=0,ks=4,vs=12,imm=0)
38: (85) call bpf_trace_printk#6      ; R0=scalar()
39: (bf) r3 = r8                      ; R3_w=map_value(off=0,ks=4,vs=12,imm=0) R8=map_value(off=0,ks=4,vs=12,imm=0)
;
40: (bf) r1 = r10                     ; R1_w=fp0 R10=fp0
41: (07) r1 += -12                    ; R1_w=fp-12
42: (b7) r2 = 12                      ; R2_w=12
43: (85) call bpf_probe_read_kernel#113       ; R0_w=scalar() fp-8=mmmmmmmm fp-16=mmmm0000
; if (c < sizeof(message)) {
44: (61) r1 = *(u32 *)(r7 +0)         ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff)) R7=map_value(off=0,ks=4,vs=16,imm=0)    
; if (c < sizeof(message)) {
45: (25) if r1 > 0xb goto pc+13       ; R1_w=scalar(umax=11,var_off=(0x0; 0xf))
; char a = message[c];
46: (18) r2 = 0xffffb05f40223004      ; R2_w=map_value(off=4,ks=4,vs=16,imm=0)
48: (0f) r2 += r1                     ; R1_w=scalar(umax=11,var_off=(0x0; 0xf)) R2_w=map_value(off=4,ks=4,vs=16,umax=11,var_off=(0x0; 0
xf),s32_max=15,u32_max=15)
49: (71) r3 = *(u8 *)(r2 +0)          ; R2_w=map_value(off=4,ks=4,vs=16,umax=11,var_off=(0x0; 0xf),s32_max=15,u32_max=15) R3_w=scalar(u
max=255,var_off=(0x0; 0xff))
50: (67) r3 <<= 56                    ; R3_w=scalar(smax=9151314442816847872,umax=18374686479671623680,var_off=(0x0; 0xff00000000000000
),s32_min=0,s32_max=0,u32_max=0)
51: (c7) r3 s>>= 56                   ; R3_w=scalar(smin=-128,smax=127)
; bpf_printk("%c", a);
52: (18) r1 = 0xffffb05f4023c003      ; R1_w=map_value(off=3,ks=4,vs=15,imm=0)
54: (b7) r2 = 3                       ; R2_w=3
55: (85) call bpf_trace_printk#6      ; R0=scalar()
; if (c <= sizeof(data.message)) {
56: (18) r1 = 0xffffb05f40223000      ; R1_w=map_value(off=0,ks=4,vs=16,imm=0)
58: (61) r1 = *(u32 *)(r1 +0)         ; R1_w=scalar(umax=4294967295,var_off=(0x0; 0xffffffff))
; if (c <= sizeof(data.message)) {
59: (25) if r1 > 0xc goto pc+10       ; R1_w=scalar(umax=12,var_off=(0x0; 0xf))
60: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
; char a = data.message[c];
61: (07) r2 += -40                    ; R2_w=fp-40
62: (0f) r2 += r1                     ; R1_w=scalar(umax=12,var_off=(0x0; 0xf)) R2_w=fp(off=-40,umax=12,var_off=(0x0; 0xf),s32_max=15,u
32_max=15)
63: (71) r3 = *(u8 *)(r2 +28)
invalid variable-offset read from stack R2 var_off=(0x0; 0xf) size=1
processed 57 insns (limit 1000000) max_states_per_insn 0 total_states 3 peak_states 3 mark_read 2
Failed to load BPF object
```

</details>
