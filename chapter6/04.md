## Question 04

编写一个挂载到追踪点（tracepoint）的程序。（你或许已经在第 4 章的练习题中完成过这个任务。）参考[7.4.3 Tracepoints](https://gaoyangu.github.io/wiki/ebpf/learning-ebpf-07/#7-4-3-Tracepoints)一节，你会看到一个上下文参数的结构体定义，它以如下字段开头：

```c
unsigned short common_type;
unsigned char common_flags;
unsigned char common_preempt_count;
int common_pid;
```

自定义一个以如下内容开头的结构体，然后将程序中的上下文参数设置为指向该结构体的指针。在程序中尝试访问这些字段中的任意一个，你会发现校验器会报出 `invalid bpf_context access` 错误并判定程序无效。

## Answer

1. 参考 [chapter7/hello.bpf.c], 修改代码

```c
struct my_syscalls_enter_execve {
	unsigned short common_type;
    unsigned char common_flags;
    unsigned char common_preempt_count;
    int common_pid;

	long syscall_nr;
	void *filename_ptr;
	long argv_ptr;
	long envp_ptr;
};

SEC("tp/syscalls/sys_enter_execve")
int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) {
   struct data_t data = {}; 

   bpf_probe_read_kernel(&data.message, sizeof(data.message), tp_msg);
   bpf_printk("%s: ctx->filename_ptr: %s", tp_msg, ctx->filename_ptr);

   // 访问 common_pid 导致校验器会报出 invalid bpf_context access 错误
   bpf_printk("%s: ctx->common_pid: %d", tp_msg, ctx->common_pid);

   data.pid = bpf_get_current_pid_tgid() >> 32;
   data.uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;

   bpf_get_current_comm(&data.command, sizeof(data.command));
   bpf_probe_read_user(&data.path, sizeof(data.path), ctx->filename_ptr);  

   bpf_perf_event_output(ctx, &output, BPF_F_CURRENT_CPU, &data, sizeof(data));   
   return 0;
}
```

2. 编译运行

```sh
$ ./hello
...
; bpf_printk("%s: ctx->common_pid: %d", tp_msg, ctx->common_pid);
22: (61) r4 = *(u32 *)(r6 +4)
invalid bpf_context access off=4 size=4
...
```

<details>
<summary>完整输出信息</summary>

```sh
libbpf: prog 'tp_sys_enter_execve': BPF program load failed: Permission denied
libbpf: prog 'tp_sys_enter_execve': failed to load: -13
libbpf: failed to load object 'hello_bpf'
libbpf: failed to load BPF skeleton 'hello_bpf': -13
reg type unsupported for arg#0 function tp_sys_enter_execve#54
0: R1=ctx(off=0,imm=0) R10=fp0
; int tp_sys_enter_execve(struct my_syscalls_enter_execve *ctx) {
0: (bf) r6 = r1                       ; R1=ctx(off=0,imm=0) R6_w=ctx(off=0,imm=0)
1: (b7) r1 = 0                        ; R1_w=0
; struct data_t data = {};
2: (63) *(u32 *)(r10 -8) = r1         ; R1_w=0 R10=fp0 fp-8=????0000
3: (7b) *(u64 *)(r10 -16) = r1        ; R1_w=0 R10=fp0 fp-16_w=00000000
4: (7b) *(u64 *)(r10 -24) = r1        ; R1_w=0 R10=fp0 fp-24_w=00000000
5: (7b) *(u64 *)(r10 -32) = r1        ; R1_w=0 R10=fp0 fp-32_w=00000000
6: (7b) *(u64 *)(r10 -40) = r1        ; R1_w=0 R10=fp0 fp-40_w=00000000
7: (7b) *(u64 *)(r10 -48) = r1        ; R1_w=0 R10=fp0 fp-48_w=00000000
8: (7b) *(u64 *)(r10 -56) = r1        ; R1_w=0 R10=fp0 fp-56_w=00000000
9: (bf) r1 = r10                      ; R1_w=fp0 R10=fp0
10: (07) r1 += -32                    ; R1_w=fp-32
; bpf_probe_read_kernel(&data.message, sizeof(data.message), tp_msg);
11: (b7) r2 = 12                      ; R2_w=12
12: (18) r3 = 0xffffb05f401c8030      ; R3_w=map_value(off=48,ks=4,vs=209,imm=0)
14: (85) call bpf_probe_read_kernel#113       ; R0_w=scalar() fp-24_w=0000mmmm fp-32_w=mmmmmmmm
; bpf_printk("%s: ctx->filename_ptr: %s", tp_msg, ctx->filename_ptr);
15: (79) r4 = *(u64 *)(r6 +16)        ; R4_w=scalar() R6_w=ctx(off=0,imm=0)
16: (18) r1 = 0xffffb05f401c8060      ; R1_w=map_value(off=96,ks=4,vs=209,imm=0)
18: (b7) r2 = 26                      ; R2_w=26
19: (18) r3 = 0xffffb05f401c8030      ; R3_w=map_value(off=48,ks=4,vs=209,imm=0)
21: (85) call bpf_trace_printk#6      ; R0=scalar()
; bpf_printk("%s: ctx->common_pid: %d", tp_msg, ctx->common_pid);
22: (61) r4 = *(u32 *)(r6 +4)
invalid bpf_context access off=4 size=4
processed 20 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 1
() & 0xFFFFFFFF;
19: (85) call bpf_get_current_uid_gid#15      ; R0_w=scalar()
; data.uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
20: (63) *(u32 *)(r10 -52) = r0       ; R0_w=scalar() R10=fp0 fp-56=mmmmmmmm
; struct data_t data = {};
21: (bf) r1 = r10                     ; R1_w=fp0 R10=fp0
22: (07) r1 += -48                    ; R1_w=fp-48
; bpf_get_current_comm(&data.command, sizeof(data.command));
23: (b7) r2 = 16                      ; R2_w=16
24: (85) call bpf_get_current_comm#16         ; R0=scalar() fp-40=mmmmmmmm fp-48=mmmmmmmm
25: (b7) r1 = 0                       ; R1_w=0
26: (0f) r7 += r1                     ; R1_w=0 R7_w=ptr_pt_regs(off=0,imm=0)
27: (bf) r1 = r10                     ; R1_w=fp0 R10=fp0
;
28: (07) r1 += -64                    ; R1_w=fp-64
; const char *name = BPF_CORE_READ(filename, name);
29: (b7) r2 = 8                       ; R2_w=8
30: (bf) r3 = r7                      ; R3_w=ptr_pt_regs(off=0,imm=0) R7_w=ptr_pt_regs(off=0,imm=0)
31: (85) call bpf_probe_read_kernel#113       ; R0_w=scalar() fp-64=mmmmmmmm
; const char *name = BPF_CORE_READ(filename, name);
32: (79) r7 = *(u64 *)(r10 -64)       ; R7_w=scalar() R10=fp0 fp-64=mmmmmmmm
; bpf_probe_read_kernel(&data.path, sizeof(data.path), name);
33: (bf) r1 = r10                     ; R1_w=fp0 R10=fp0
34: (07) r1 += -20                    ; R1_w=fp-20
; bpf_probe_read_kernel(&data.path, sizeof(data.path), name);
35: (b7) r2 = 16                      ; R2_w=16
36: (bf) r3 = r7                      ; R3_w=scalar(id=1) R7_w=scalar(id=1)
37: (85) call bpf_probe_read_kernel#113       ; R0=scalar() fp-8=????mmmm fp-16=mmmmmmmm fp-24=mmmmmmmm
; bpf_printk("%s: filename->name: %s", fentry_msg, name);
38: (18) r1 = 0xffffb05f401c80ba      ; R1_w=map_value(off=186,ks=4,vs=209,imm=0)
40: (b7) r2 = 23                      ; R2_w=23
41: (18) r3 = 0xffffb05f401c8020      ; R3_w=map_value(off=32,ks=4,vs=209,imm=0)
43: (bf) r4 = r7                      ; R4_w=scalar(id=1) R7=scalar(id=1)
44: (85) call bpf_trace_printk#6      ; R0_w=scalar()
45: (bf) r4 = r10                     ; R4_w=fp0 R10=fp0
;
46: (07) r4 += -56                    ; R4_w=fp-56
; bpf_perf_event_output(ctx, &output, BPF_F_CURRENT_CPU, &data, sizeof(data));
47: (bf) r1 = r6                      ; R1_w=ctx(off=0,imm=0) R6=ctx(off=0,imm=0)
48: (18) r2 = 0xffff96bd0ee3e600      ; R2_w=map_ptr(off=0,ks=4,vs=4,imm=0)
50: (18) r3 = 0xffffffff              ; R3_w=4294967295
52: (b7) r5 = 52                      ; R5_w=52
53: (85) call bpf_perf_event_output#25        ; R0=scalar()
; int BPF_PROG(fentry_execve, struct filename *filename) {
54: (b7) r0 = 0                       ; R0_w=0
55: (95) exit
0_w=scalar()
; int BPF_KPROBE_SYSCALL(kprobe_sys_execve, const char *pathname)
100: (b7) r0 = 0                      ; R0_w=0
101: (95) exit
sched_process_exec size=20 vlen=5
        ent type_id=57 bits_offset=0
        __data_loc_filename type_id=12 bits_offset=64
        pid type_id=58 bits_offset=96
        old_pid type_id=58 bits_offset=128
        __data type_id=60 bits_offset=160
[57] STRUCT trace_entry size=8 vlen=4
        type type_id=27 bits_offset=0
        flags type_id=50 bits_offset=16
        preempt_count type_id=50 bits_offset=24
        pid type_id=2 bits_offset=32
[58] TYPEDEF pid_t type_id=59
[59] TYPEDEF __kernel_pid_t type_id=2
[60] ARRAY (anon) type_id=17 index_type_id=4 nr_elems=0
[61] FUNC_PROTO (anon) return=2 args=(55 ctx)
[62] FUNC tp_btf_exec type_id=61
[63] PTR (anon) type_id=64
[64] STRUCT bpf_raw_tracepoint_args size=0 vlen=1
        args type_id=65 bits_offset=0
[65] ARRAY (anon) type_id=29 index_type_id=4 nr_elems=0
[66] FUNC_PROTO (anon) return=2 args=(63 ctx)
[67] FUNC raw_tp_exec type_id=66
[68] ARRAY (anon) type_id=40 index_type_id=4 nr_elems=16
[69] VAR kprobe_sys_msg type_id=68 linkage=1
[70] VAR kprobe_msg type_id=68 linkage=1
[71] VAR fentry_msg type_id=68 linkage=1
[72] VAR tp_msg type_id=68 linkage=1
[73] VAR tp_btf_exec_msg type_id=68 linkage=1
[74] VAR raw_tp_exec_msg type_id=68 linkage=1
[75] INT _Bool size=1 bits_offset=0 nr_bits=8 encoding=BOOL
[76] VAR LINUX_HAS_SYSCALL_WRAPPER type_id=75 linkage=1
[77] ARRAY (anon) type_id=40 index_type_id=4 nr_elems=26
[78] VAR tp_sys_enter_execve.____fmt type_id=77 linkage=0
[79] ARRAY (anon) type_id=40 index_type_id=4 nr_elems=24
[80] VAR tp_sys_enter_execve.____fmt.1 type_id=79 linkage=0
[81] ARRAY (anon) type_id=17 index_type_id=4 nr_elems=13
[82] VAR LICENSE type_id=81 linkage=1
[83] ARRAY (anon) type_id=40 index_type_id=4 nr_elems=17
[84] VAR ____kprobe_sys_execve.____fmt type_id=83 linkage=0
[85] ARRAY (anon) type_id=40 index_type_id=4 nr_elems=23
[86] VAR ____kprobe_do_execve.____fmt type_id=85 linkage=0
[87] VAR ____fentry_execve.____fmt type_id=85 linkage=0
[88] DATASEC .kconfig size=1 vlen=1
         type_id=76 offset=0 size=1
[89] DATASEC .maps size=56 vlen=2
         type_id=6 offset=0 size=24
         type_id=20 offset=24 size=32
[90] DATASEC .rodata size=209 vlen=11
         type_id=69 offset=0 size=16
         type_id=70 offset=16 size=16
         type_id=71 offset=32 size=16
         type_id=72 offset=48 size=16
         type_id=73 offset=64 size=16
         type_id=74 offset=80 size=16
         type_id=78 offset=96 size=26
         type_id=80 offset=122 size=24
         type_id=84 offset=146 size=17
         type_id=86 offset=163 size=23
         type_id=87 offset=186 size=23
[91] DATASEC license size=13 vlen=1
         type_id=82 offset=0 size=13
[92] FWD audit_names struct
Failed to load BPF object
```

</details>
